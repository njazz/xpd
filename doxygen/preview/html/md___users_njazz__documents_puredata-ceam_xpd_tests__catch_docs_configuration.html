<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>XPD: configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XPD
   </div>
   <div id="projectbrief">C/C++ wrapper for PureData</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">configuration </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Catch is designed to "just work" as much as possible. For most people the only configuration needed is telling Catch which source file should host all the implementation code (<code>CATCH_CONFIG_MAIN</code>).</p>
<p>Nonetheless there are still some occasions where finer control is needed. For these occasions Catch exposes a set of macros for configuring how it is built.</p>
<h1>main()/ implementation</h1>
<pre class="fragment">CATCH_CONFIG_MAIN   // Designates this as implementation file and defines main()
CATCH_CONFIG_RUNNER // Designates this as implementation file
</pre><p>Although Catch is header only it still, internally, maintains a distinction between interface headers and headers that contain implementation. Only one source file in your test project should compile the implementation headers and this is controlled through the use of one of these macros - one of these identifiers should be defined before including Catch in <em>exactly one implementation file in your project</em>.</p>
<h1>Prefixing Catch macros</h1>
<pre class="fragment">CATCH_CONFIG_PREFIX_ALL
</pre><p>To keep test code clean and uncluttered Catch uses short macro names (e.g. <code>TEST_CASE</code> and <code>REQUIRE</code>). Occasionally these may conflict with identifiers from platform headers or the system under test. In this case the above identifier can be defined. This will cause all the Catch user macros to be prefixed with <code>CATCH_</code> (e.g. <code>CATCH_TEST_CASE</code> and <code>CATCH_REQUIRE</code>).</p>
<h1>Terminal colour</h1>
<pre class="fragment">CATCH_CONFIG_COLOUR_NONE    // completely disables all text colouring
CATCH_CONFIG_COLOUR_WINDOWS // forces the Win32 console API to be used
CATCH_CONFIG_COLOUR_ANSI    // forces ANSI colour codes to be used
</pre><p>Yes, I am English, so I will continue to spell "colour" with a 'u'.</p>
<p>When sending output to the terminal, if it detects that it can, Catch will use colourised text. On Windows the Win32 API, <code>SetConsoleTextAttribute</code>, is used. On POSIX systems ANSI colour escape codes are inserted into the stream.</p>
<p>For finer control you can define one of the above identifiers (these are mutually exclusive - but that is not checked so may behave unexpectedly if you mix them):</p>
<p>Note that when ANSI colour codes are used "unistd.h" must be includable - along with a definition of <code>isatty()</code></p>
<p>Typically you should place the <code>#define</code> before #including "catch.hpp" in your main source file - but if you prefer you can define it for your whole project by whatever your IDE or build system provides for you to do so.</p>
<h1>Console width</h1>
<pre class="fragment">CATCH_CONFIG_CONSOLE_WIDTH = x // where x is a number
</pre><p>Catch formats output intended for the console to fit within a fixed number of characters. This is especially important as indentation is used extensively and uncontrolled line wraps break this. By default a console width of 80 is assumed but this can be controlled by defining the above identifier to be a different value.</p>
<h1>stdout</h1>
<pre class="fragment">CATCH_CONFIG_NOSTDOUT
</pre><p>Catch does not use <code>std::cout</code> and <code>std::cerr</code> directly but gets them from <code>Catch::cout()</code> and <code>Catch::cerr()</code> respectively. If the above identifier is defined these functions are left unimplemented and you must implement them yourself. Their signatures are: </p>
<pre class="fragment">std::ostream&amp; cout();
std::ostream&amp; cerr();
</pre><p>This can be useful on certain platforms that do not provide <code>std::cout</code> and <code>std::cerr</code>, such as certain embedded systems.</p>
<h1>C++ conformance toggles</h1>
<pre class="fragment">CATCH_CONFIG_CPP11_NULLPTR                 // nullptr is supported?
CATCH_CONFIG_CPP11_NOEXCEPT                // noexcept is supported?
CATCH_CONFIG_CPP11_GENERATED_METHODS       // delete and default keywords for methods
CATCH_CONFIG_CPP11_IS_ENUM                 // std::is_enum is supported?
CATCH_CONFIG_CPP11_TUPLE                   // std::tuple is supported
CATCH_CONFIG_VARIADIC_MACROS               // Usually pre-C++11 compiler extensions are sufficient
CATCH_CONFIG_CPP11_LONG_LONG               // generates overloads for the long long type
CATCH_CONFIG_CPP11_OVERRIDE                // CATCH_OVERRIDE expands to override (for virtual function implementations)
CATCH_CONFIG_CPP11_UNIQUE_PTR              // Use std::unique_ptr instead of std::auto_ptr
CATCH_CONFIG_CPP11_SHUFFLE                 // Use std::shuffle instead of std::random_shuffle
CATCH_CONFIG_CPP11_TYPE_TRAITS             // Use std::enable_if and &lt;type_traits&gt;
CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK // Use C++11 expression SFINAE to check if class can be inserted to std::ostream
</pre><p>Catch has some basic compiler detection that will attempt to select the appropriate mix of these macros. However being incomplete - and often without access to the respective compilers - this detection tends to be conservative. So overriding control is given to the user. If a compiler supports a feature (and Catch does not already detect it) then one or more of these may be defined to enable it (or suppress it, in some cases). If you do do this please raise an issue, specifying your compiler version (ideally with an idea of how to detect it) and stating that it has such support. You may also suppress any of these features by using the <code>_NO_</code> form, e.g. <code>CATCH_CONFIG_CPP11_NO_NULLPTR</code>.</p>
<p>All C++11 support can be disabled with <code>CATCH_CONFIG_NO_CPP11</code></p>
<h2><code>CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK</code></h2>
<p>This flag is off by default, but allows you to resolve problems caused by types with private base class that are streamable, but the classes themselves are not. Without it, the following code will cause a compilation error: ```cpp #define CATCH_CONFIG_MAIN #include &lt;catch.hpp&gt; struct A {}; std::ostream &amp;operator&lt;&lt; (std::ostream &amp;o, const A &amp;v) { return o &lt;&lt; 0; }</p>
<p>struct B : private A { bool operator==(int){ return true;} };</p>
<p>B f (); std::ostream g ();</p>
<p>TEST_CASE ("Error in streamable check") { B x; REQUIRE (x == 4); } ```</p>
<h1>Other toggles</h1>
<pre class="fragment">CATCH_CONFIG_COUNTER                    // Use __COUNTER__ to generate unique names for test cases
CATCH_CONFIG_WINDOWS_SEH                // Enable SEH handling on Windows
CATCH_CONFIG_FAST_COMPILE               // Sacrifices some (rather minor) features for compilation speed
CATCH_CONFIG_POSIX_SIGNALS              // Enable handling POSIX signals
CATCH_CONFIG_WINDOWS_CRTDBG             // Enable leak checking using Windows's CRT Debug Heap
</pre><p>Currently Catch enables <code>CATCH_CONFIG_WINDOWS_SEH</code> only when compiled with MSVC, because some versions of MinGW do not have the necessary Win32 API support.</p>
<p><code>CATCH_CONFIG_POSIX_SIGNALS</code> is on by default, except when Catch is compiled under <code>Cygwin</code>, where it is disabled by default (but can be force-enabled by defining <code>CATCH_CONFIG_POSIX_SIGNALS</code>).</p>
<p><code>CATCH_CONFIG_WINDOWS_CRTDBG</code> is off by default. If enabled, Windows's CRT is used to check for memory leaks, and displays them after the tests finish running.</p>
<p>Just as with the C++11 conformance toggles, these toggles can be disabled by using <code>_NO_</code> form of the toggle, e.g. <code>CATCH_CONFIG_NO_WINDOWS_SEH</code>.</p>
<h2><code>CATCH_CONFIG_FAST_COMPILE</code></h2>
<p>Defining this flag speeds up compilation of test files by ~20%, by making 2 changes:</p>
<ul>
<li>The <code>-b</code> (<code>--break</code>) flag no longer makes Catch break into debugger in the same stack frame as the failed test, but rather in a stack frame <em>below</em>.</li>
<li>The <code>REQUIRE</code> family of macros (<code>REQUIRE</code>, <code>REQUIRE_FALSE</code> and <code>REQUIRE_THAT</code>) no longer uses local try-catch block. This disables exception translation, but should not lead to false negatives.</li>
</ul>
<p><code>CATCH_CONFIG_FAST_COMPILE</code> has to be either defined, or not defined, in all translation units that are linked into single test binary, or the behaviour of setting <code>-b</code> flag and throwing unexpected exceptions will be unpredictable.</p>
<h1>Windows header clutter</h1>
<p>On Windows Catch includes <code>windows.h</code>. To minimize global namespace clutter in the implementation file, it defines <code>NOMINMAX</code> and <code>WIN32_LEAN_AND_MEAN</code> before including it. You can control this behaviour via two macros: </p>
<pre class="fragment">CATCH_CONFIG_NO_NOMINMAX            // Stops Catch from using NOMINMAX macro 
CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN // Stops Catch from using WIN32_LEAN_AND_MEAN macro
</pre><hr/>
<p><a href="Readme.md">Home</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 25 2018 17:46:47 for XPD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
