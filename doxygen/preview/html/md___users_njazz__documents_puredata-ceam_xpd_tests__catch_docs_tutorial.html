<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>XPD: Getting Catch</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XPD
   </div>
   <div id="projectbrief">C/C++ wrapper for PureData</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Getting Catch </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The simplest way to get Catch is to download the latest <a href="https://raw.githubusercontent.com/philsquared/Catch/master/single_include/catch.hpp">single header version</a>. The single header is generated by merging a set of individual headers but it is still just normal source code in a header file.</p>
<p>The full source for Catch, including test projects, documentation, and other things, is hosted on GitHub. <a href="http://catch-lib.net">http://catch-lib.net</a> will redirect you there.</p>
<h2>Where to put it?</h2>
<p>Catch is header only. All you need to do is drop the file(s) somewhere reachable from your project - either in some central location you can set your header search path to find, or directly into your project tree itself! This is a particularly good option for other Open-Source projects that want to use Catch for their test suite. See <a href="http://www.levelofindirection.com/journal/2011/5/27/unit-testing-in-c-and-objective-c-just-got-ridiculously-easi.html">this blog entry for more on that</a>.</p>
<p>The rest of this tutorial will assume that the Catch single-include header (or the include folder) is available unqualified - but you may need to prefix it with a folder name if necessary.</p>
<h1>Writing tests</h1>
<p>Let's start with a really simple example. Say you have written a function to calculate factorials and now you want to test it (let's leave aside TDD for now).</p>
<p>```c++ unsigned int Factorial( unsigned int number ) { return number &lt;= 1 ? number : Factorial(number-1)*number; } ```</p>
<p>To keep things simple we'll put everything in a single file (<a href="#scaling-up">see later for more on how to structure your test files</a>)</p>
<p>```c++ #define CATCH_CONFIG_MAIN // This tells Catch to provide a main() - only do this in one cpp file #include "catch.hpp"</p>
<p>unsigned int Factorial( unsigned int number ) { return number &lt;= 1 ? number : Factorial(number-1)*number; }</p>
<p>TEST_CASE( "Factorials are computed", "[factorial]" ) { REQUIRE( Factorial(1) == 1 ); REQUIRE( Factorial(2) == 2 ); REQUIRE( Factorial(3) == 6 ); REQUIRE( Factorial(10) == 3628800 ); } ```</p>
<p>This will compile to a complete executable which responds to <a href="command-line.md">command line arguments</a>. If you just run it with no arguments it will execute all test cases (in this case there is just one), report any failures, report a summary of how many tests passed and failed and return the number of failed tests (useful for if you just want a yes/ no answer to: "did it work").</p>
<p>If you run this as written it will pass. Everything is good. Right? Well, there is still a bug here. In fact the first version of this tutorial I posted here genuinely had the bug in! So it's not completely contrived (thanks to Daryle Walker (<code>@CTMacUser</code>) for pointing this out).</p>
<p>What is the bug? Well what is the factorial of zero? <a href="http://mathforum.org/library/drmath/view/57128.html">The factorial of zero is one</a> - which is just one of those things you have to know (and remember!).</p>
<p>Let's add that to the test case:</p>
<p>```c++ TEST_CASE( "Factorials are computed", "[factorial]" ) { REQUIRE( Factorial(0) == 1 ); REQUIRE( Factorial(1) == 1 ); REQUIRE( Factorial(2) == 2 ); REQUIRE( Factorial(3) == 6 ); REQUIRE( Factorial(10) == 3628800 ); } ```</p>
<p>Now we get a failure - something like:</p>
<p>``` Example.cpp:9: FAILED: REQUIRE( Factorial(0) == 1 ) with expansion: 0 == 1 ```</p>
<p>Note that we get the actual return value of Factorial(0) printed for us (0) - even though we used a natural expression with the == operator. That lets us immediately see what the problem is.</p>
<p>Let's change the factorial function to:</p>
<p>```c++ unsigned int Factorial( unsigned int number ) { return number &gt; 1 ? Factorial(number-1)*number : 1; } ```</p>
<p>Now all the tests pass.</p>
<p>Of course there are still more issues to deal with. For example we'll hit problems when the return value starts to exceed the range of an unsigned int. With factorials that can happen quite quickly. You might want to add tests for such cases and decide how to handle them. We'll stop short of doing that here.</p>
<h2>What did we do here?</h2>
<p>Although this was a simple test it's been enough to demonstrate a few things about how Catch is used. Let's take moment to consider those before we move on.</p>
<ol type="1">
<li>All we did was <code>#define</code> one identifier and <code>#include</code> one header and we got everything - even an implementation of <code>main()</code> that will <a href="command-line.md">respond to command line arguments</a>. You can only use that <code>#define</code> in one implementation file, for (hopefully) obvious reasons. Once you have more than one file with unit tests in you'll just <code>#include "catch.hpp"</code> and go. Usually it's a good idea to have a dedicated implementation file that just has <code>#define CATCH_CONFIG_MAIN</code> and <code>#include "catch.hpp"</code>. You can also provide your own implementation of main and drive Catch yourself (see <a href="own-main.md">Supplying-your-own-main()</a>).</li>
<li>We introduce test cases with the <code>TEST_CASE</code> macro. This macro takes one or two arguments - a free form test name and, optionally, one or more tags (for more see <a href="#test-cases-and-sections">Test cases and Sections</a>, ). The test name must be unique. You can run sets of tests by specifying a wildcarded test name or a tag expression. See the <a href="command-line.md">command line docs</a> for more information on running tests.</li>
<li>The name and tags arguments are just strings. We haven't had to declare a function or method - or explicitly register the test case anywhere. Behind the scenes a function with a generated name is defined for you, and automatically registered using static registry classes. By abstracting the function name away we can name our tests without the constraints of identifier names.</li>
<li>We write our individual test assertions using the <code>REQUIRE</code> macro. Rather than a separate macro for each type of condition we express the condition naturally using C/C++ syntax. Behind the scenes a simple set of expression templates captures the left-hand-side and right-hand-side of the expression so we can display the values in our test report. As we'll see later there <em>are</em> other assertion macros - but because of this technique the number of them is drastically reduced.</li>
</ol>
<h2>Test cases and sections</h2>
<p>Most test frameworks have a class-based fixture mechanism. That is, test cases map to methods on a class and common setup and teardown can be performed in <code>setup()</code> and <code>teardown()</code> methods (or constructor/ destructor in languages, like C++, that support deterministic destruction).</p>
<p>While Catch fully supports this way of working there are a few problems with the approach. In particular the way your code must be split up, and the blunt granularity of it, may cause problems. You can only have one setup/ teardown pair across a set of methods, but sometimes you want slightly different setup in each method, or you may even want several levels of setup (a concept which we will clarify later on in this tutorial). It was <a href="http://jamesnewkirk.typepad.com/posts/2007/09/why-you-should-.html">problems like these</a> that led James Newkirk, who led the team that built NUnit, to start again from scratch and <a href="http://jamesnewkirk.typepad.com/posts/2007/09/announcing-xuni.html">build xUnit</a>).</p>
<p>Catch takes a different approach (to both NUnit and xUnit) that is a more natural fit for C++ and the C family of languages. This is best explained through an example:</p>
<p>```c++ TEST_CASE( "vectors can be sized and resized", "[vector]" ) { </p>
<pre class="fragment">std::vector&lt;int&gt; v( 5 );

REQUIRE( v.size() == 5 );
REQUIRE( v.capacity() &gt;= 5 );

SECTION( "resizing bigger changes size and capacity" ) {
    v.resize( 10 );

    REQUIRE( v.size() == 10 );
    REQUIRE( v.capacity() &gt;= 10 );
}
SECTION( "resizing smaller changes size but not capacity" ) {
    v.resize( 0 );

    REQUIRE( v.size() == 0 );
    REQUIRE( v.capacity() &gt;= 5 );
}
SECTION( "reserving bigger changes capacity but not size" ) {
    v.reserve( 10 );

    REQUIRE( v.size() == 5 );
    REQUIRE( v.capacity() &gt;= 10 );
}
SECTION( "reserving smaller does not change size or capacity" ) {
    v.reserve( 0 );

    REQUIRE( v.size() == 5 );
    REQUIRE( v.capacity() &gt;= 5 );
}
</pre><p> } ```</p>
<p>For each <code>SECTION</code> the <code>TEST_CASE</code> is executed from the start - so as we enter each section we know that size is 5 and capacity is at least 5. We enforced those requirements with the <code>REQUIRE</code>s at the top level so we can be confident in them. This works because the <code>SECTION</code> macro contains an if statement that calls back into Catch to see if the section should be executed. One leaf section is executed on each run through a <code>TEST_CASE</code>. The other sections are skipped. Next time through the next section is executed, and so on until no new sections are encountered.</p>
<p>So far so good - this is already an improvement on the setup/teardown approach because now we see our setup code inline and use the stack.</p>
<p>The power of sections really shows, however, when we need to execute a sequence of, checked, operations. Continuing the vector example, we might want to verify that attempting to reserve a capacity smaller than the current capacity of the vector changes nothing. We can do that, naturally, like so:</p>
<p>```c++ SECTION( "reserving bigger changes capacity but not size" ) { v.reserve( 10 );</p>
<p>REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 10 );</p>
<p>SECTION( "reserving smaller again does not change capacity" ) { v.reserve( 7 );</p>
<p>REQUIRE( v.capacity() &gt;= 10 ); } } ```</p>
<p>Sections can be nested to an arbitrary depth (limited only by your stack size). Each leaf section (i.e. a section that contains no nested sections) will be executed exactly once, on a separate path of execution from any other leaf section (so no leaf section can interfere with another). A failure in a parent section will prevent nested sections from running - but then that's the idea.</p>
<h2>BDD-Style</h2>
<p>If you name your test cases and sections appropriately you can achieve a BDD-style specification structure. This became such a useful way of working that first class support has been added to Catch. Scenarios can be specified using <code>SCENARIO</code>, <code>GIVEN</code>, <code>WHEN</code> and <code>THEN</code> macros, which map on to <code>TEST_CASE</code>s and <code>SECTION</code>s, respectively. For more details see <a href="test-cases-and-sections.md">Test cases and sections</a>.</p>
<p>The vector example can be adjusted to use these macros like so:</p>
<p>```c++ SCENARIO( "vectors can be sized and resized", "[vector]" ) { </p>
<pre class="fragment">GIVEN( "A vector with some items" ) {
    std::vector&lt;int&gt; v( 5 );

    REQUIRE( v.size() == 5 );
    REQUIRE( v.capacity() &gt;= 5 );

    WHEN( "the size is increased" ) {
        v.resize( 10 );

        THEN( "the size and capacity change" ) {
            REQUIRE( v.size() == 10 );
            REQUIRE( v.capacity() &gt;= 10 );
        }
    }
    WHEN( "the size is reduced" ) {
        v.resize( 0 );

        THEN( "the size changes but not capacity" ) {
            REQUIRE( v.size() == 0 );
            REQUIRE( v.capacity() &gt;= 5 );
        }
    }
    WHEN( "more capacity is reserved" ) {
        v.reserve( 10 );

        THEN( "the capacity changes but not the size" ) {
            REQUIRE( v.size() == 5 );
            REQUIRE( v.capacity() &gt;= 10 );
        }
    }
    WHEN( "less capacity is reserved" ) {
        v.reserve( 0 );

        THEN( "neither size nor capacity are changed" ) {
            REQUIRE( v.size() == 5 );
            REQUIRE( v.capacity() &gt;= 5 );
        }
    }
}
</pre><p> } ```</p>
<p>Conveniently, these tests will be reported as follows when run:</p>
<p>``` Scenario: vectors can be sized and resized Given: A vector with some items When: more capacity is reserved Then: the capacity changes but not the size ```</p>
<h2>Scaling up</h2>
<p>To keep the tutorial simple we put all our code in a single file. This is fine to get started - and makes jumping into Catch even quicker and easier. As you write more real-world tests, though, this is not really the best approach.</p>
<p>The requirement is that the following block of code (<a href="own-main.md">or equivalent</a>):</p>
<p>```c++ #define CATCH_CONFIG_MAIN #include "catch.hpp" ```</p>
<p>appears in <em>exactly one</em> source file. Use as many additional cpp files (or whatever you call your implementation files) as you need for your tests, partitioned however makes most sense for your way of working. Each additional file need only <code>#include "catch.hpp"</code> - do not repeat the <code>#define</code>!</p>
<p>In fact it is usually a good idea to put the block with the <code>#define</code> <a href="slow-compiles.md">in its own source file</a>.</p>
<p>Do not write your tests in header files!</p>
<h2>Next steps</h2>
<p>This has been a brief introduction to get you up and running with Catch, and to point out some of the key differences between Catch and other frameworks you may already be familiar with. This will get you going quite far already and you are now in a position to dive in and write some tests.</p>
<p>Of course there is more to learn - most of which you should be able to page-fault in as you go. Please see the ever-growing <a href="Readme.md">Reference section</a> for what's available. </p>
<hr/>
<p><a href="Readme.md">Home</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 25 2018 17:46:48 for XPD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
