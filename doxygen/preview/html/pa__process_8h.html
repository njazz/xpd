<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>XPD: /Users/njazz/Documents/puredata-ceam/xpd/pd/pure-data/portaudio/portaudio/src/common/pa_process.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XPD
   </div>
   <div id="projectbrief">C/C++ wrapper for PureData</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_695ae6a37edf2996f6d6c89c01e2f5f0.html">pd</a></li><li class="navelem"><a class="el" href="dir_9dc290e3925aa5ea2d82996c48e85c70.html">pure-data</a></li><li class="navelem"><a class="el" href="dir_8d1827aa840fab43fc578e39c8a7d790.html">portaudio</a></li><li class="navelem"><a class="el" href="dir_ee80ea99013c45a0790acb035f0ce078.html">portaudio</a></li><li class="navelem"><a class="el" href="dir_650fe226515732cfafc840bedc0334b8.html">src</a></li><li class="navelem"><a class="el" href="dir_6ab5c1d8de575915a3a9d65b062bb226.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">pa_process.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Buffer Processor prototypes. A Buffer Processor performs buffer length adaption, coordinates sample format conversion, and interleaves/deinterleaves channels.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="portaudio_8h_source.html">portaudio.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pa__converters_8h_source.html">pa_converters.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pa__dither_8h_source.html">pa_dither.h</a>&quot;</code><br/>
</div>
<p><a href="pa__process_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pa_util_channel_descriptor.html">PaUtilChannelDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auxilliary data structure used internally by the buffer processor to represent host input and output buffers.  <a href="struct_pa_util_channel_descriptor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main buffer processor data structure.  <a href="struct_pa_util_buffer_processor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab595814fb534b35f08ed1a34bfbbf923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab595814fb534b35f08ed1a34bfbbf923"></a>
typedef struct <br class="typebreak"/>
<a class="el" href="struct_pa_util_channel_descriptor.html">PaUtilChannelDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#ab595814fb534b35f08ed1a34bfbbf923">PaUtilChannelDescriptor</a></td></tr>
<tr class="memdesc:ab595814fb534b35f08ed1a34bfbbf923"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auxilliary data structure used internally by the buffer processor to represent host input and output buffers. <br/></td></tr>
<tr class="separator:ab595814fb534b35f08ed1a34bfbbf923"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a16c84d8c0ac62944797f530bf852484f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484f">PaUtilHostBufferSizeMode</a> { <a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484fa5e79e1ea4d8f114cfe83caa9b08610d8">paUtilFixedHostBufferSize</a>, 
<a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484fa2e97156fbdf5444b7bcc53b60f368d8b">paUtilBoundedHostBufferSize</a>, 
<a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484fa4273c3f42fdaa887af00afa2bdb03cc0">paUtilUnknownHostBufferSize</a>, 
<a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484fa90f2d4ab46cdebfe7efaadc602bf3c78">paUtilVariableHostBufferSizePartialUsageAllowed</a>
 }</td></tr>
<tr class="memdesc:a16c84d8c0ac62944797f530bf852484f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode flag passed to PaUtil_InitializeBufferProcessor indicating the type of buffering that the host API uses.  <a href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484f">More...</a><br/></td></tr>
<tr class="separator:a16c84d8c0ac62944797f530bf852484f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization, termination, resetting and info</div></td></tr>
<tr class="memitem:adbf068f554a245c493eb0817ad8bc67e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="portaudio_8h.html#a4949e4a8ef9f9dbe8cbee414ce69841d">PaError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#adbf068f554a245c493eb0817ad8bc67e">PaUtil_InitializeBufferProcessor</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, int inputChannelCount, <a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a> userInputSampleFormat, <a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a> hostInputSampleFormat, int outputChannelCount, <a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a> userOutputSampleFormat, <a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a> hostOutputSampleFormat, double sampleRate, <a class="el" href="portaudio_8h.html#a37c7ac3ace7d2dd1430f40ecdee4ebb6">PaStreamFlags</a> streamFlags, unsigned long framesPerUserBuffer, unsigned long framesPerHostBuffer, <a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484f">PaUtilHostBufferSizeMode</a> hostBufferSizeMode, <a class="el" href="portaudio_8h.html#a8a60fb2a5ec9cbade3f54a9c978e2710">PaStreamCallback</a> *streamCallback, void *userData)</td></tr>
<tr class="separator:adbf068f554a245c493eb0817ad8bc67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af872943fc77bbc32f0196e86f16a7c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#af872943fc77bbc32f0196e86f16a7c24">PaUtil_TerminateBufferProcessor</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor)</td></tr>
<tr class="separator:af872943fc77bbc32f0196e86f16a7c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f82fd15e56b10ed8e858be9ad8765e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a6f82fd15e56b10ed8e858be9ad8765e3">PaUtil_ResetBufferProcessor</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor)</td></tr>
<tr class="separator:a6f82fd15e56b10ed8e858be9ad8765e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4871dfd93b00739e0dafdd4ea7671c9a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a4871dfd93b00739e0dafdd4ea7671c9a">PaUtil_GetBufferProcessorInputLatencyFrames</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor)</td></tr>
<tr class="separator:a4871dfd93b00739e0dafdd4ea7671c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a70efcd9dd7c8e1ea735580dee7e4a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a92a70efcd9dd7c8e1ea735580dee7e4a">PaUtil_GetBufferProcessorOutputLatencyFrames</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor)</td></tr>
<tr class="separator:a92a70efcd9dd7c8e1ea735580dee7e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Host buffer pointer configuration</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions to set host input and output buffers, used by both callback streams and blocking read/write streams. </p>
</div></td></tr>
<tr class="memitem:a5201db0d922fac6e3b513bf8c4d59149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a5201db0d922fac6e3b513bf8c4d59149">PaUtil_SetInputFrameCount</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned long frameCount)</td></tr>
<tr class="separator:a5201db0d922fac6e3b513bf8c4d59149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c4eca9005b038a32877bdcebc1dbc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a46c4eca9005b038a32877bdcebc1dbc9">PaUtil_SetNoInput</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor)</td></tr>
<tr class="separator:a46c4eca9005b038a32877bdcebc1dbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b89245c209d2a0b367ed8d82bde5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a98b89245c209d2a0b367ed8d82bde5ca">PaUtil_SetInputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data, unsigned int stride)</td></tr>
<tr class="separator:a98b89245c209d2a0b367ed8d82bde5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62cb33b10a25676a03a0bc0c0134eaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#ab62cb33b10a25676a03a0bc0c0134eaa">PaUtil_SetInterleavedInputChannels</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int firstChannel, void *data, unsigned int channelCount)</td></tr>
<tr class="separator:ab62cb33b10a25676a03a0bc0c0134eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309097fe924b746ac3e05260993abb42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a309097fe924b746ac3e05260993abb42">PaUtil_SetNonInterleavedInputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data)</td></tr>
<tr class="separator:a309097fe924b746ac3e05260993abb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469724724e74e5e1a8ea97f98f2d76bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a469724724e74e5e1a8ea97f98f2d76bd">PaUtil_Set2ndInputFrameCount</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned long frameCount)</td></tr>
<tr class="separator:a469724724e74e5e1a8ea97f98f2d76bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d233c8e934e1495f4b40d6baf2c8c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a89d233c8e934e1495f4b40d6baf2c8c9">PaUtil_Set2ndInputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data, unsigned int stride)</td></tr>
<tr class="separator:a89d233c8e934e1495f4b40d6baf2c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad483fb76f7a894c0c085b7b054fcc993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#ad483fb76f7a894c0c085b7b054fcc993">PaUtil_Set2ndInterleavedInputChannels</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int firstChannel, void *data, unsigned int channelCount)</td></tr>
<tr class="separator:ad483fb76f7a894c0c085b7b054fcc993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0f949512c7b443c72dbc8fdee2cb5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a7a0f949512c7b443c72dbc8fdee2cb5b">PaUtil_Set2ndNonInterleavedInputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data)</td></tr>
<tr class="separator:a7a0f949512c7b443c72dbc8fdee2cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe79d7110067c783ec401e8961bebe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#aafe79d7110067c783ec401e8961bebe8">PaUtil_SetOutputFrameCount</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned long frameCount)</td></tr>
<tr class="separator:aafe79d7110067c783ec401e8961bebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf981028bf1d439959fe2287f51306fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#acf981028bf1d439959fe2287f51306fa">PaUtil_SetNoOutput</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor)</td></tr>
<tr class="separator:acf981028bf1d439959fe2287f51306fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d622722b03549d8f274aae5b8e5a93c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a7d622722b03549d8f274aae5b8e5a93c">PaUtil_SetOutputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data, unsigned int stride)</td></tr>
<tr class="separator:a7d622722b03549d8f274aae5b8e5a93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e31c5710305b2beb153f8f39b922623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a3e31c5710305b2beb153f8f39b922623">PaUtil_SetInterleavedOutputChannels</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int firstChannel, void *data, unsigned int channelCount)</td></tr>
<tr class="separator:a3e31c5710305b2beb153f8f39b922623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8108f7e3e890843830654e7cc4d176f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a8108f7e3e890843830654e7cc4d176f1">PaUtil_SetNonInterleavedOutputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data)</td></tr>
<tr class="separator:a8108f7e3e890843830654e7cc4d176f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24af08a401dcc32a29a155f196ac3839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a24af08a401dcc32a29a155f196ac3839">PaUtil_Set2ndOutputFrameCount</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned long frameCount)</td></tr>
<tr class="separator:a24af08a401dcc32a29a155f196ac3839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67081555880d451b1c5c6c5ab2189b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#ad67081555880d451b1c5c6c5ab2189b0">PaUtil_Set2ndOutputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data, unsigned int stride)</td></tr>
<tr class="separator:ad67081555880d451b1c5c6c5ab2189b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9077bfaf0ac1f9f06f3afd9359a842d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a9077bfaf0ac1f9f06f3afd9359a842d6">PaUtil_Set2ndInterleavedOutputChannels</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int firstChannel, void *data, unsigned int channelCount)</td></tr>
<tr class="separator:a9077bfaf0ac1f9f06f3afd9359a842d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2be8935e0862a1fbe157260ed1f8b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#abf2be8935e0862a1fbe157260ed1f8b8">PaUtil_Set2ndNonInterleavedOutputChannel</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned int channel, void *data)</td></tr>
<tr class="separator:abf2be8935e0862a1fbe157260ed1f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Buffer processing functions for callback streams</div></td></tr>
<tr class="memitem:ae791a33948eed0a902d618bfd0e0a825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#ae791a33948eed0a902d618bfd0e0a825">PaUtil_BeginBufferProcessing</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, <a class="el" href="struct_pa_stream_callback_time_info.html">PaStreamCallbackTimeInfo</a> *timeInfo, <a class="el" href="portaudio_8h.html#a55a005924bcfa0424594f4f65cd4ae82">PaStreamCallbackFlags</a> callbackStatusFlags)</td></tr>
<tr class="separator:ae791a33948eed0a902d618bfd0e0a825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbc470b417a31de0b9944d476adaaa0"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#afbbc470b417a31de0b9944d476adaaa0">PaUtil_EndBufferProcessing</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, int *callbackResult)</td></tr>
<tr class="separator:afbbc470b417a31de0b9944d476adaaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa330f62537935124788387624d6a5362"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#aa330f62537935124788387624d6a5362">PaUtil_IsBufferProcessorOutputEmpty</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor)</td></tr>
<tr class="separator:aa330f62537935124788387624d6a5362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Buffer processing functions for blocking read/write streams</div></td></tr>
<tr class="memitem:a9a8ada1e97f38a135c1cd229affc538c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pa__process_8h.html#a9a8ada1e97f38a135c1cd229affc538c">PaUtil_CopyInput</a> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, void **buffer, unsigned long frameCount)</td></tr>
<tr class="separator:a9a8ada1e97f38a135c1cd229affc538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32b13037c9e4fcda0e1af1041102d9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af32b13037c9e4fcda0e1af1041102d9c"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>PaUtil_CopyOutput</b> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, const void **buffer, unsigned long frameCount)</td></tr>
<tr class="separator:af32b13037c9e4fcda0e1af1041102d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59efdbd92383b5388e484188827c2eb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59efdbd92383b5388e484188827c2eb1"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>PaUtil_ZeroOutput</b> (<a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *bufferProcessor, unsigned long frameCount)</td></tr>
<tr class="separator:a59efdbd92383b5388e484188827c2eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Buffer Processor prototypes. A Buffer Processor performs buffer length adaption, coordinates sample format conversion, and interleaves/deinterleaves channels. </p>
<h3>Overview</h3>
<p>The "Buffer Processor" (<a class="el" href="struct_pa_util_buffer_processor.html" title="The main buffer processor data structure. ">PaUtilBufferProcessor</a>) manages conversion of audio data from host buffers to user buffers and back again. Where required, the buffer processor takes care of converting between host and user sample formats, interleaving and deinterleaving multichannel buffers, and adapting between host and user buffers with different lengths. The buffer processor may be used with full and half duplex streams, for both callback streams and blocking read/write streams.</p>
<p>One of the important capabilities provided by the buffer processor is the ability to adapt between user and host buffer sizes of different lengths with minimum latency. Although this task is relatively easy to perform when the host buffer size is an integer multiple of the user buffer size, the problem is more complicated when this is not the case - especially for full-duplex callback streams. Where necessary the adaption is implemented by internally buffering some input and/or output data. The buffer adation algorithm used by the buffer processor was originally implemented by Stephan Letz for the ASIO version of PortAudio, and is described in his Callback_adaption_.pdf which is included in the distribution.</p>
<p>The buffer processor performs sample conversion using the functions provided by <a class="el" href="pa__converters_8c.html" title="Conversion function implementations. ">pa_converters.c</a>.</p>
<p>The following sections provide an overview of how to use the buffer processor. Interested readers are advised to consult the host API implementations for examples of buffer processor usage.</p>
<h4>Initialization, resetting and termination</h4>
<p>When a stream is opened, the buffer processor should be initialized using PaUtil_InitializeBufferProcessor. This function initializes internal state and allocates temporary buffers as neccesary according to the supplied configuration parameters. Some of the parameters correspond to those requested by the user in their call to <a class="el" href="portaudio_8h.html#a443ad16338191af364e3be988014cbbe">Pa_OpenStream()</a>, others reflect the requirements of the host API implementation - they indicate host buffer sizes, formats, and the type of buffering which the Host API uses. The buffer processor should be initialized for callback streams and blocking read/write streams.</p>
<p>Call PaUtil_ResetBufferProcessor to clear any sample data which is present in the buffer processor before starting to use it (for example when Pa_StartStream is called).</p>
<p>When the buffer processor is no longer used call PaUtil_TerminateBufferProcessor.</p>
<h4>Using the buffer processor for a callback stream</h4>
<p>The buffer processor's role in a callback stream is to take host input buffers process them with the stream callback, and fill host output buffers. For a full duplex stream, the buffer processor handles input and output simultaneously due to the requirements of the minimum-latency buffer adation algorithm.</p>
<p>When a host buffer becomes available, the implementation should call the buffer processor to process the buffer. The buffer processor calls the stream callback to consume and/or produce audio data as necessary. The buffer processor will convert sample formats, interleave/deinterleave channels, and slice or chunk the data to the appropriate buffer lengths according to the requirements of the stream callback and the host API.</p>
<p>To process a host buffer (or a pair of host buffers for a full-duplex stream) use the following calling sequence:</p>
<ol type="1">
<li>Call PaUtil_BeginBufferProcessing</li>
<li>For a stream which takes input:<ul>
<li>Call PaUtil_SetInputFrameCount with the number of frames in the host input buffer.</li>
<li>Call one of the following functions one or more times to tell the buffer processor about the host input buffer(s): PaUtil_SetInputChannel, PaUtil_SetInterleavedInputChannels, PaUtil_SetNonInterleavedInputChannel. Which function you call will depend on whether the host buffer(s) are interleaved or not.</li>
<li>If the available host data is split accross two buffers (for example a data range at the end of a circular buffer and another range at the beginning of the circular buffer), also call PaUtil_Set2ndInputFrameCount, PaUtil_Set2ndInputChannel, PaUtil_Set2ndInterleavedInputChannels, PaUtil_Set2ndNonInterleavedInputChannel as necessary to tell the buffer processor about the second buffer.</li>
</ul>
</li>
<li>For a stream which generates output:<ul>
<li>Call PaUtil_SetOutputFrameCount with the number of frames in the host output buffer.</li>
<li>Call one of the following functions one or more times to tell the buffer processor about the host output buffer(s): PaUtil_SetOutputChannel, PaUtil_SetInterleavedOutputChannels, PaUtil_SetNonInterleavedOutputChannel. Which function you call will depend on whether the host buffer(s) are interleaved or not.</li>
<li>If the available host output buffer space is split accross two buffers (for example a data range at the end of a circular buffer and another range at the beginning of the circular buffer), call PaUtil_Set2ndOutputFrameCount, PaUtil_Set2ndOutputChannel, PaUtil_Set2ndInterleavedOutputChannels, PaUtil_Set2ndNonInterleavedOutputChannel as necessary to tell the buffer processor about the second buffer.</li>
</ul>
</li>
<li>Call PaUtil_EndBufferProcessing, this function performs the actual data conversion and processing.</li>
</ol>
<h4>Using the buffer processor for a blocking read/write stream</h4>
<p>Blocking read/write streams use the buffer processor to convert and copy user output data to a host buffer, and to convert and copy host input data to the user's buffer. The buffer processor does not perform any buffer adaption. When using the buffer processor in a blocking read/write stream the input and output conversion are performed separately by the PaUtil_CopyInput and PaUtil_CopyOutput functions.</p>
<p>To copy data from a host input buffer to the buffer(s) which the user supplies to Pa_ReadStream, use the following calling sequence.</p>
<ul>
<li>Repeat the following three steps until the user buffer(s) have been filled with samples from the host input buffers:<ol type="1">
<li>Call PaUtil_SetInputFrameCount with the number of frames in the host input buffer.</li>
<li>Call one of the following functions one or more times to tell the buffer processor about the host input buffer(s): PaUtil_SetInputChannel, PaUtil_SetInterleavedInputChannels, PaUtil_SetNonInterleavedInputChannel. Which function you call will depend on whether the host buffer(s) are interleaved or not.</li>
<li>Call PaUtil_CopyInput with the user buffer pointer (or a copy of the array of buffer pointers for a non-interleaved stream) passed to Pa_ReadStream, along with the number of frames in the user buffer(s). Be careful to pass a <em>copy</em> of the user buffer pointers to PaUtil_CopyInput because PaUtil_CopyInput advances the pointers to the start of the next region to copy.</li>
</ol>
</li>
<li>PaUtil_CopyInput will not copy more data than is available in the host buffer(s), so the above steps need to be repeated until the user buffer(s) are full.</li>
</ul>
<p>To copy data to the host output buffer from the user buffers(s) supplied to Pa_WriteStream use the following calling sequence.</p>
<ul>
<li>Repeat the following three steps until all frames from the user buffer(s) have been copied to the host API:<ol type="1">
<li>Call PaUtil_SetOutputFrameCount with the number of frames in the host output buffer.</li>
<li>Call one of the following functions one or more times to tell the buffer processor about the host output buffer(s): PaUtil_SetOutputChannel, PaUtil_SetInterleavedOutputChannels, PaUtil_SetNonInterleavedOutputChannel. Which function you call will depend on whether the host buffer(s) are interleaved or not.</li>
<li>Call PaUtil_CopyOutput with the user buffer pointer (or a copy of the array of buffer pointers for a non-interleaved stream) passed to Pa_WriteStream, along with the number of frames in the user buffer(s). Be careful to pass a <em>copy</em> of the user buffer pointers to PaUtil_CopyOutput because PaUtil_CopyOutput advances the pointers to the start of the next region to copy.</li>
</ol>
</li>
<li>PaUtil_CopyOutput will not copy more data than fits in the host buffer(s), so the above steps need to be repeated until all user data is copied. </li>
</ul>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a16c84d8c0ac62944797f530bf852484f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484f">PaUtilHostBufferSizeMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode flag passed to PaUtil_InitializeBufferProcessor indicating the type of buffering that the host API uses. </p>
<p>The mode used depends on whether the host API or the implementation manages the buffers, and how these buffers are used (scatter gather, circular buffer). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a16c84d8c0ac62944797f530bf852484fa5e79e1ea4d8f114cfe83caa9b08610d8"></a>paUtilFixedHostBufferSize</em>&nbsp;</td><td class="fielddoc">
<p>The host buffer size is a fixed known size. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a16c84d8c0ac62944797f530bf852484fa2e97156fbdf5444b7bcc53b60f368d8b"></a>paUtilBoundedHostBufferSize</em>&nbsp;</td><td class="fielddoc">
<p>The host buffer size may vary, but has a known maximum size. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a16c84d8c0ac62944797f530bf852484fa4273c3f42fdaa887af00afa2bdb03cc0"></a>paUtilUnknownHostBufferSize</em>&nbsp;</td><td class="fielddoc">
<p>Nothing is known about the host buffer size. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a16c84d8c0ac62944797f530bf852484fa90f2d4ab46cdebfe7efaadc602bf3c78"></a>paUtilVariableHostBufferSizePartialUsageAllowed</em>&nbsp;</td><td class="fielddoc">
<p>The host buffer size varies, and the client does not require the buffer processor to consume all of the input and fill all of the output buffer. This is useful when the implementation has access to the host API's circular buffer and only needs to consume/fill some of it, not necessarily all of it, with each call to the buffer processor. This is the only mode where <a class="el" href="pa__process_8c.html#a2bce3edf65753593f4f4005e917ad9e4">PaUtil_EndBufferProcessing()</a> may not consume the whole buffer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae791a33948eed0a902d618bfd0e0a825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_BeginBufferProcessing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pa_stream_callback_time_info.html">PaStreamCallbackTimeInfo</a> *&#160;</td>
          <td class="paramname"><em>timeInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="portaudio_8h.html#a55a005924bcfa0424594f4f65cd4ae82">PaStreamCallbackFlags</a>&#160;</td>
          <td class="paramname"><em>callbackStatusFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commence processing a host buffer (or a pair of host buffers in the full-duplex case) for a callback stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor.</td></tr>
    <tr><td class="paramname">timeInfo</td><td>Timing information for the first sample of the host buffer(s). This information may be adjusted when buffer adaption is being performed.</td></tr>
    <tr><td class="paramname">callbackStatusFlags</td><td>Flags indicating whether underruns and overruns have occurred since the last time the buffer processor was called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a8ada1e97f38a135c1cd229affc538c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long PaUtil_CopyInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>frameCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy samples from host input channels set up by the PaUtil_Set*InputChannels functions to a user supplied buffer. This function is intended for use with blocking read/write streams. Copies the minimum of the number of user frames (specified by the frameCount parameter) and the number of available host frames (specified in a previous call to SetInputFrameCount()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the user buffer pointer, or a pointer to a pointer to an array of user buffer pointers for a non-interleaved stream. It is important that this parameter points to a copy of the user buffer pointers, not to the actual user buffer pointers, because this function updates the pointers before returning.</td></tr>
    <tr><td class="paramname">frameCount</td><td>The number of frames of data in the buffer(s) pointed to by the buffer parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of frames copied. The buffer pointer(s) pointed to by the buffer parameter are advanced to point to the frame(s) following the last one filled. </dd></dl>

</div>
</div>
<a class="anchor" id="afbbc470b417a31de0b9944d476adaaa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long PaUtil_EndBufferProcessing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>callbackResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finish processing a host buffer (or a pair of host buffers in the full-duplex case) for a callback stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor.</td></tr>
    <tr><td class="paramname">callbackResult</td><td>On input, indicates a previous callback result, and on exit, the result of the user stream callback, if it is called. On entry callbackResult should contain one of { paContinue, paComplete, or paAbort}. If paComplete is passed, the stream callback will not be called but any audio that was generated by previous stream callbacks will be copied to the output buffer(s). You can check whether the buffer processor's internal buffer is empty by calling PaUtil_IsBufferProcessorOutputEmpty.</td></tr>
  </table>
  </dd>
</dl>
<p>If the stream callback is called its result is stored in *callbackResult. If the stream callback returns paComplete or paAbort, all output buffers will be full of valid data - some of which may be zeros to acount for data that wasn't generated by the terminating callback.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of frames processed. This usually corresponds to the number of frames specified by the PaUtil_Set*FrameCount functions, exept in the paUtilVariableHostBufferSizePartialUsageAllowed buffer size mode when a smaller value may be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a4871dfd93b00739e0dafdd4ea7671c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long PaUtil_GetBufferProcessorInputLatencyFrames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the input latency of a buffer processor, in frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input latency introduced by the buffer processor, in frames.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a92a70efcd9dd7c8e1ea735580dee7e4a">PaUtil_GetBufferProcessorOutputLatencyFrames</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a92a70efcd9dd7c8e1ea735580dee7e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long PaUtil_GetBufferProcessorOutputLatencyFrames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the output latency of a buffer processor, in frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output latency introduced by the buffer processor, in frames.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a4871dfd93b00739e0dafdd4ea7671c9a">PaUtil_GetBufferProcessorInputLatencyFrames</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbf068f554a245c493eb0817ad8bc67e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="portaudio_8h.html#a4949e4a8ef9f9dbe8cbee414ce69841d">PaError</a> PaUtil_InitializeBufferProcessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputChannelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a>&#160;</td>
          <td class="paramname"><em>userInputSampleFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a>&#160;</td>
          <td class="paramname"><em>hostInputSampleFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outputChannelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a>&#160;</td>
          <td class="paramname"><em>userOutputSampleFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="portaudio_8h.html#a4582d93c2c2e60e12be3d74c5fe00b96">PaSampleFormat</a>&#160;</td>
          <td class="paramname"><em>hostOutputSampleFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="portaudio_8h.html#a37c7ac3ace7d2dd1430f40ecdee4ebb6">PaStreamFlags</a>&#160;</td>
          <td class="paramname"><em>streamFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>framesPerUserBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>framesPerHostBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484f">PaUtilHostBufferSizeMode</a>&#160;</td>
          <td class="paramname"><em>hostBufferSizeMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="portaudio_8h.html#a8a60fb2a5ec9cbade3f54a9c978e2710">PaStreamCallback</a> *&#160;</td>
          <td class="paramname"><em>streamCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a buffer processor's representation stored in a <a class="el" href="struct_pa_util_buffer_processor.html" title="The main buffer processor data structure. ">PaUtilBufferProcessor</a> structure. Be sure to call PaUtil_TerminateBufferProcessor after finishing with a buffer processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor structure to initialize.</td></tr>
    <tr><td class="paramname">inputChannelCount</td><td>The number of input channels as passed to Pa_OpenStream or 0 for an output-only stream.</td></tr>
    <tr><td class="paramname">userInputSampleFormat</td><td>Format of user input samples, as passed to Pa_OpenStream. This parameter is ignored for ouput-only streams.</td></tr>
    <tr><td class="paramname">hostInputSampleFormat</td><td>Format of host input samples. This parameter is ignored for output-only streams. See note about host buffer interleave below.</td></tr>
    <tr><td class="paramname">outputChannelCount</td><td>The number of output channels as passed to Pa_OpenStream or 0 for an input-only stream.</td></tr>
    <tr><td class="paramname">userOutputSampleFormat</td><td>Format of user output samples, as passed to Pa_OpenStream. This parameter is ignored for input-only streams.</td></tr>
    <tr><td class="paramname">hostOutputSampleFormat</td><td>Format of host output samples. This parameter is ignored for input-only streams. See note about host buffer interleave below.</td></tr>
    <tr><td class="paramname">sampleRate</td><td>Sample rate of the stream. The more accurate this is the better - it is used for updating time stamps when adapting buffers.</td></tr>
    <tr><td class="paramname">streamFlags</td><td>Stream flags as passed to Pa_OpenStream, this parameter is used for selecting special sample conversion options such as clipping and dithering.</td></tr>
    <tr><td class="paramname">framesPerUserBuffer</td><td>Number of frames per user buffer, as requested by the framesPerBuffer parameter to Pa_OpenStream. This parameter may be zero to indicate that the user will accept any (and varying) buffer sizes.</td></tr>
    <tr><td class="paramname">framesPerHostBuffer</td><td>Specifies the number of frames per host buffer for the fixed buffer size mode, and the maximum number of frames per host buffer for the bounded host buffer size mode. It is ignored for the other modes.</td></tr>
    <tr><td class="paramname">hostBufferSizeMode</td><td>A mode flag indicating the size variability of host buffers that will be passed to the buffer processor. See PaUtilHostBufferSizeMode for further details.</td></tr>
    <tr><td class="paramname">streamCallback</td><td>The user stream callback passed to Pa_OpenStream.</td></tr>
    <tr><td class="paramname">userData</td><td>The user data field passed to Pa_OpenStream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The interleave flag is ignored for host buffer formats. Host interleave is determined by the use of different SetInput and SetOutput functions.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An error code indicating whether the initialization was successful. If the error code is not PaNoError, the buffer processor was not initialized and should not be used.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__front_8c.html#a443ad16338191af364e3be988014cbbe">Pa_OpenStream</a>, <a class="el" href="pa__process_8h.html#a16c84d8c0ac62944797f530bf852484f" title="Mode flag passed to PaUtil_InitializeBufferProcessor indicating the type of buffering that the host A...">PaUtilHostBufferSizeMode</a>, <a class="el" href="pa__process_8h.html#af872943fc77bbc32f0196e86f16a7c24">PaUtil_TerminateBufferProcessor</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa330f62537935124788387624d6a5362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PaUtil_IsBufferProcessorOutputEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether any callback generated output remains in the bufffer processor's internal buffers. This method may be used to determine when to continue calling <a class="el" href="pa__process_8c.html#a2bce3edf65753593f4f4005e917ad9e4">PaUtil_EndBufferProcessing()</a> after the callback has returned a callbackResult of paComplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns non-zero when callback generated output remains in the internal buffer and zero (0) when there internal buffer contains no callback generated data. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f82fd15e56b10ed8e858be9ad8765e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_ResetBufferProcessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear any internally buffered data. If you call PaUtil_InitializeBufferProcessor in your OpenStream routine, make sure you call PaUtil_ResetBufferProcessor in your StartStream call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89d233c8e934e1495f4b40d6baf2c8c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndInputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the input buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a98b89245c209d2a0b367ed8d82bde5ca">PaUtil_SetInputChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a469724724e74e5e1a8ea97f98f2d76bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndInputFrameCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>frameCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the input buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a5201db0d922fac6e3b513bf8c4d59149">PaUtil_SetInputFrameCount</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad483fb76f7a894c0c085b7b054fcc993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndInterleavedInputChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channelCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the input buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#ab62cb33b10a25676a03a0bc0c0134eaa">PaUtil_SetInterleavedInputChannels</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9077bfaf0ac1f9f06f3afd9359a842d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndInterleavedOutputChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channelCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the output buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a3e31c5710305b2beb153f8f39b922623">PaUtil_SetInterleavedOutputChannels</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a0f949512c7b443c72dbc8fdee2cb5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndNonInterleavedInputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the input buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a309097fe924b746ac3e05260993abb42">PaUtil_SetNonInterleavedInputChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf2be8935e0862a1fbe157260ed1f8b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndNonInterleavedOutputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the output buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a8108f7e3e890843830654e7cc4d176f1">PaUtil_SetNonInterleavedOutputChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad67081555880d451b1c5c6c5ab2189b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndOutputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the output buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a7d622722b03549d8f274aae5b8e5a93c">PaUtil_SetOutputChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a24af08a401dcc32a29a155f196ac3839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_Set2ndOutputFrameCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>frameCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use for the second buffer half when the output buffer is split in two halves. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#aafe79d7110067c783ec401e8961bebe8">PaUtil_SetOutputFrameCount</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a98b89245c209d2a0b367ed8d82bde5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetInputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the buffer processor with a pointer to a host input channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel number. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>The stride from one sample to the next, in samples. For interleaved host buffers, the stride will usually be the same as the number of channels in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5201db0d922fac6e3b513bf8c4d59149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetInputFrameCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>frameCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of frames in the input host buffer(s) specified by the PaUtil_Set*InputChannel functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor.</td></tr>
    <tr><td class="paramname">frameCount</td><td>The number of host input frames. A 0 frameCount indicates to use the framesPerHostBuffer value passed to PaUtil_InitializeBufferProcessor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a46c4eca9005b038a32877bdcebc1dbc9">PaUtil_SetNoInput</a>, <a class="el" href="pa__process_8h.html#a98b89245c209d2a0b367ed8d82bde5ca">PaUtil_SetInputChannel</a>, <a class="el" href="pa__process_8h.html#ab62cb33b10a25676a03a0bc0c0134eaa">PaUtil_SetInterleavedInputChannels</a>, <a class="el" href="pa__process_8h.html#a309097fe924b746ac3e05260993abb42">PaUtil_SetNonInterleavedInputChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab62cb33b10a25676a03a0bc0c0134eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetInterleavedInputChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channelCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the buffer processor with a pointer to an number of interleaved host input channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
    <tr><td class="paramname">firstChannel</td><td>The first channel number. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer. </td></tr>
    <tr><td class="paramname">channelCount</td><td>The number of interleaved channels in the buffer. If channelCount is zero, the number of channels specified to PaUtil_InitializeBufferProcessor will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e31c5710305b2beb153f8f39b922623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetInterleavedOutputChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>firstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channelCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the buffer processor with a pointer to a number of interleaved host output channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
    <tr><td class="paramname">firstChannel</td><td>The first channel number. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer. </td></tr>
    <tr><td class="paramname">channelCount</td><td>The number of interleaved channels in the buffer. If channelCount is zero, the number of channels specified to PaUtil_InitializeBufferProcessor will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46c4eca9005b038a32877bdcebc1dbc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetNoInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate that no input is avalable. This function should be used when priming the output of a full-duplex stream opened with the paPrimeOutputBuffersUsingStreamCallback flag. Note that it is not necessary to call this or any othe PaUtil_Set*Input* functions for ouput-only streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a309097fe924b746ac3e05260993abb42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetNonInterleavedInputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the buffer processor with a pointer to one non-interleaved host output channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel number. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8108f7e3e890843830654e7cc4d176f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetNonInterleavedOutputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the buffer processor with a pointer to one non-interleaved host output channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel number. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf981028bf1d439959fe2287f51306fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetNoOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate that the output will be discarded. This function should be used when implementing the paNeverDropInput mode for full duplex streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d622722b03549d8f274aae5b8e5a93c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetOutputChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the buffer processor with a pointer to a host output channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel number. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>The stride from one sample to the next, in samples. For interleaved host buffers, the stride will usually be the same as the number of channels in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafe79d7110067c783ec401e8961bebe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_SetOutputFrameCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>frameCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of frames in the output host buffer(s) specified by the PaUtil_Set*OutputChannel functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor.</td></tr>
    <tr><td class="paramname">frameCount</td><td>The number of host output frames. A 0 frameCount indicates to use the framesPerHostBuffer value passed to PaUtil_InitializeBufferProcessor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#a7d622722b03549d8f274aae5b8e5a93c">PaUtil_SetOutputChannel</a>, <a class="el" href="pa__process_8h.html#a3e31c5710305b2beb153f8f39b922623">PaUtil_SetInterleavedOutputChannels</a>, <a class="el" href="pa__process_8h.html#a8108f7e3e890843830654e7cc4d176f1">PaUtil_SetNonInterleavedOutputChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af872943fc77bbc32f0196e86f16a7c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PaUtil_TerminateBufferProcessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pa_util_buffer_processor.html">PaUtilBufferProcessor</a> *&#160;</td>
          <td class="paramname"><em>bufferProcessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminate a buffer processor's representation. Deallocates any temporary buffers allocated by PaUtil_InitializeBufferProcessor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferProcessor</td><td>The buffer processor structure to terminate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pa__process_8h.html#adbf068f554a245c493eb0817ad8bc67e">PaUtil_InitializeBufferProcessor</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 25 2018 17:46:47 for XPD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
