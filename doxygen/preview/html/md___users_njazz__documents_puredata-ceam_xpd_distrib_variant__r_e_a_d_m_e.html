<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>XPD: Mapbox Variant</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">XPD
   </div>
   <div id="projectbrief">C/C++ wrapper for PureData</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Mapbox Variant </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An header-only alternative to <code>boost::variant</code> for C++11 and C++14</p>
<p><a href="https://travis-ci.org/mapbox/variant">![Build Status](https://secure.travis-ci.org/mapbox/variant.svg)</a> <a href="https://ci.appveyor.com/project/Mapbox/variant">![Build status](https://ci.appveyor.com/api/projects/status/v9tatx21j1k0fcgy)</a> <a href="https://coveralls.io/r/mapbox/variant?branch=master">![Coverage Status](https://coveralls.io/repos/mapbox/variant/badge.svg?branch=master&amp;service=github)</a></p>
<h2>Introduction</h2>
<p>Variant's basic building blocks are:</p>
<ul>
<li><code>variant&lt;Ts...&gt;</code> - a type-safe representation for sum-types / discriminated unions</li>
<li><code>recursive_wrapper&lt;T&gt;</code> - a helper type to represent recursive "tree-like" variants</li>
<li><code>apply_visitor(visitor, myVariant)</code> - to invoke a custom visitor on the variant's underlying type</li>
<li><code>get&lt;T&gt;()</code> - a function to directly unwrap a variant's underlying type</li>
<li><code>.match([](Type){})</code> - a variant convenience member function taking an arbitrary number of lambdas creating a visitor behind the scenes and applying it to the variant</li>
</ul>
<h3>Basic Usage - HTTP API Example</h3>
<p>Suppose you want to represent a HTTP API response which is either a JSON result or an error:</p>
<p>```c++ struct Result { Json object; };</p>
<p>struct <a class="el" href="struct_error.html">Error</a> { int32_t code; string message; }; ```</p>
<p>You can represent this at type level using a variant which is either an <code><a class="el" href="struct_error.html">Error</a></code> or a <code>Result</code>:</p>
<p>```c++ using <a class="el" href="struct_response.html">Response</a> = variant&lt;Error, Result&gt;;</p>
<p><a class="el" href="struct_response.html">Response</a> makeRequest() { return <a class="el" href="struct_error.html">Error</a>{501, "Not Implemented"}; }</p>
<p><a class="el" href="struct_response.html">Response</a> ret = makeRequest(); ```</p>
<p>To see which type the <code><a class="el" href="struct_response.html">Response</a></code> holds you pattern match on the variant unwrapping the underlying value:</p>
<p>```c++ ret.match([] (Result r) { print(r.object); }, [] (<a class="el" href="struct_error.html">Error</a> e) { print(e.message); }); ```</p>
<p>Instead of using the variant's convenience <code>.match</code> pattern matching function you can create a type visitor functor and use <code>apply_visitor</code> manually:</p>
<p>```c++ struct ResponseVisitor { void operator()(Result r) const { print(r.object); }</p>
<p>void operator()(Error e) const { print(e.message); } };</p>
<p>ResponseVisitor visitor; apply_visitor(visitor, ret); ```</p>
<p>In both cases the compiler makes sure you handle all types the variant can represent at compile.</p>
<h3>Recursive Variants - JSON Example</h3>
<p><a href="http://www.json.org/">JSON</a> consists of types <code>String</code>, <code>Number</code>, <code>True</code>, <code>False</code>, <code>Null</code>, <code>Array</code> and <code>Object</code>.</p>
<p>```c++ struct String { string value; }; struct Number { double value; }; struct True { }; struct False { }; struct Null { }; struct Array { vector&lt;?&gt; values; }; struct Object { unordered_map&lt;string, ?&gt; values; }; ```</p>
<p>This works for primitive types but how do we represent recursive types such as <code>Array</code> which can hold multiple elements and <code>Array</code> itself, too?</p>
<p>For these use cases Variant provides a <code>recursive_wrapper</code> helper type which lets you express recursive Variants.</p>
<p>```c++ struct String { string value; }; struct Number { double value; }; struct True { }; struct False { }; struct Null { };</p>
<p>// Forward declarations only struct Array; struct Object;</p>
<p>using Value = variant&lt;String, Number, True, False, Null, recursive_wrapper&lt;Array&gt;, recursive_wrapper&lt;Object&gt;&gt;;</p>
<p>struct Array { vector&lt;Value&gt; values; };</p>
<p>struct Object { unordered_map&lt;string, Value&gt; values; }; ```</p>
<p>For walkig the JSON representation you can again either create a <code>JSONVisitor</code>:</p>
<p>```c++ struct JSONVisitor {</p>
<p>void operator()(Null) const { print("null"); }</p>
<p>// same for all other JSON types };</p>
<p>JSONVisitor visitor; apply_visitor(visitor, json); ```</p>
<p>Or use the convenience <code>.match</code> pattern matching function:</p>
<p>```c++ json.match([] (Null) { print("null"); }, ...); ```</p>
<p>To summarize: use <code>recursive_wrapper</code> to represent recursive "tree-like" representations:</p>
<p>```c++ struct <a class="el" href="struct_empty.html">Empty</a> { }; struct <a class="el" href="struct_node.html">Node</a>;</p>
<p>using Tree = variant&lt;<a class="el" href="struct_empty.html">Empty</a>, recursive_wrapper&lt;Node&gt;&gt;;</p>
<p>struct <a class="el" href="struct_node.html">Node</a> { uint64_t value; } ``` </p>
<h3>Advanced Usage Tips</h3>
<p>Creating type aliases for variants is a great way to reduce repetition. Keep in mind those type aliases are not checked at type level, though. We recommend creating a new type for all but basic variant usage:</p>
<p>```c++ // the compiler can't tell the following two apart using APIResult = variant&lt;Error, Result&gt;; using FilesystemResult = variant&lt;Error, Result&gt;;</p>
<p>// new type struct APIResult : variant&lt;Error, Result&gt; { using Base = variant&lt;Error, Result&gt;; using Base::Base; } ```</p>
<h2>Why use Mapbox Variant?</h2>
<p>Mapbox variant has the same speedy performance of <code>boost::variant</code> but is faster to compile, results in smaller binaries, and has no dependencies.</p>
<p>For example on OS <a class="el" href="struct_x.html">X</a> 10.9 with clang++ and libc++:</p>
<table class="doxtable">
<tr>
<th>Test </th><th>Mapbox Variant </th><th>Boost Variant  </th></tr>
<tr>
<td>Size of pre-compiled header (release / debug) </td><td>2.8/2.8 MB </td><td>12/15 MB </td></tr>
<tr>
<td>Size of simple program linking variant (release / debug) </td><td>8/24 K </td><td>12/40 K </td></tr>
<tr>
<td>Time to compile header </td><td>185 ms </td><td>675 ms </td></tr>
</table>
<p>(Numbers from an older version of Mapbox variant.)</p>
<h2>Goals</h2>
<p>Mapbox <code>variant</code> has been a very valuable, lightweight alternative for apps that can use c++11 or c++14 but that do not want a boost dependency. Mapbox <code>variant</code> has also been useful in apps that do depend on boost, like mapnik, to help (slightly) with compile times and to majorly lessen dependence on boost in core headers. The original goal and near term goal is to maintain external API compatibility with <code>boost::variant</code> such that Mapbox <code>variant</code> can be a "drop in". At the same time the goal is to stay minimal: Only implement the features that are actually needed in existing software. So being an "incomplete" implementation is just fine.</p>
<p>Currently Mapbox variant doesn't try to be API compatible with the upcoming variant standard, because the standard is not finished and it would be too much work. But we'll revisit this decision in the future if needed.</p>
<p>If Mapbox variant is not for you, have a look at <a href="doc/other_implementations.md">these other implementations</a>.</p>
<p>Want to know more about the upcoming standard? Have a look at our <a href="doc/standards_effort.md">overview</a>.</p>
<p>Most modern high-level languages provide ways to express sum types directly. If you're curious have a look at Haskell's pattern matching or Rust's and Swift's enums.</p>
<h2>Depends</h2>
<ul>
<li>Compiler supporting <code>-std=c++11</code> or <code>-std=c++14</code></li>
</ul>
<p>Tested with:</p>
<ul>
<li>g++-4.7</li>
<li>g++-4.8</li>
<li>g++-4.9</li>
<li>g++-5.2</li>
<li>clang++-3.5</li>
<li>clang++-3.6</li>
<li>clang++-3.7</li>
<li>clang++-3.8</li>
<li>clang++-3.9</li>
<li>Visual Studio 2015</li>
</ul>
<h2>Unit Tests</h2>
<p>On Unix systems compile and run the unit tests with <code>make test</code>.</p>
<p>On Windows run <code>scripts/build-local.bat</code>.</p>
<h2>Limitations</h2>
<ul>
<li>The <code>variant</code> can not hold references (something like <code>variant&lt;int&amp;&gt;</code> is not possible). You might want to try <code>std::reference_wrapper</code> instead.</li>
</ul>
<h2>Deprecations</h2>
<ul>
<li>The included implementation of <code>optional</code> is deprecated and will be removed in a future version. See <a href="https://github.com/mapbox/variant/issues/64">https://github.com/mapbox/variant/issues/64</a>.</li>
<li>Old versions of the code needed visitors to derive from <code>static_visitor</code>. This is not needed any more and marked as deprecated. The <code>static_visitor</code> class will be removed in future versions.</li>
</ul>
<h2>Benchmarks</h2>
<pre class="fragment">make bench
</pre><h2>Check object sizes</h2>
<pre class="fragment">make sizes /path/to/boost/variant.hpp</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 25 2018 17:46:47 for XPD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
